/*
 * Copyright (c) 2003-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Surround;
using Nemerle.Utility;
using SCG = System.Collections.Generic;

namespace Nemerle.Compiler
{

  /** Transforms stream of tokens from given LexerBase to token tree
      with matched brackets.
   */
  public class PreParser : PreParserBase
  {
    public this (lex : LexerBase) {
      base (lex, lex.Manager.CoreEnv);
    }

    public this (lex : LexerBase, env : GlobalEnv) {
        base (lex, env);
    }

    /** Fetch next token (from one token buffer or lexer if it's empty */
    protected override get_token() : Token
    {
      if (stack_populated())
      {
        def result = pop_next();
        result;
      }
      else
      {
        try
        {
          match (lexer.GetToken ())
          {
            | QuotedIdentifier (x) as q => Token.Identifier (q.Location, x)
            | t => t
          }
        }
        catch
        {
          | _ is System.Text.DecoderFallbackException =>
            Message.FatalError (lexer.Location, $"detected unsupported encoding of national characters in file `$(lexer.Location.File)', "
              "source files should be in UTF8 (or UTF16/32 when BOM is given) encoding");
          | e is LexerBase.Error =>
            Message.Error (lexer.Location, e.Message + " " + e.StackTrace);
            get_token ()
        }
      }
    }

    /** Handle standard situations when new bracket group is beginning
        or there is erronous situation. Any non bracket token is
        appended to current LooseGroup.

        Throws PreParserException when there is unmatched end bracket.
     */
    protected override handle_default_token (current_begin : int, tok : Token, braces_cut_current = true, scan_ahead_for_replacements = true) : void
    {        
      _ = scan_ahead_for_replacements; // For warning
      
      match (tok)
      {
        | Token.BeginBrace(generated) as openBrace =>
          def brace_group = parse_brace_group(tok.Location, openBrace, true, generated);
          current_stream.Add(brace_group);

          when (braces_cut_current)
            if (peek_token() is Token.Semicolon)
              finish_current(current_begin, get_token());
            else
              finish_current(current_begin);

        | Token.BeginRound as openBrace =>
          def round_group = parse_round_group(tok.Location, openBrace);
          current_stream.Add(round_group);

        | Token.BeginSquare as openBrace =>
          def square_group = parse_square_group(tok.Location, openBrace);
          current_stream.Add(square_group);

        | Token.BeginQuote as openBrace =>
          def quote_group = parse_quote_group(tok.Location, openBrace);
          current_stream.Add(quote_group);

        | Token.EndRound | Token.EndSquare | Token.EndQuote | Token.EndBrace =>
          push_back (tok);
          throw PreParserException (tok.Location, $"unexpected closing bracket `$(tok)'");

        | Token.EndOfFile =>
          throw PreParserException (tok.Location, "unexpected end of file");

        | Token.Comment (comment) when doc_comments != null =>
          doc_comments = doc_comments.Replace (tok.Location, comment);

        | Token.Comment => ()
        | Token.NewLine => ()
        | _ => current_stream.Add (tok);
      }
    }

    parse_round_group(loc : Location, openBrace : Token.BeginRound) : Token.RoundGroup
    {
      def parent_begin = parent_stream.Count;
      def current_begin = current_stream.Count;

      def loop () {
        def tok = get_token ();
        match (tok) {
          // finish entire round group
          | Token.EndRound as closeBrace =>
            def round_group = finish_parent (parent_begin, current_begin);
            Token.RoundGroup (loc + tok.Location, round_group, openBrace, closeBrace);

          // finish current loose group
          | Token.Comma =>
            finish_current (current_begin, tok);
            loop ()

          | _ => handle_default_token (current_begin, tok, false); loop ()
        }
      }
      try { loop () }
      catch
      { e is PreParserException =>
        def Manager = lexer.Manager; // need for surroundwith (related_messages)
        surroundwith (related_messages)
        {
          Message.Error (loc, "unclosed bracket");
          Message.Hint (e.Location, $"$(e.Message) when parsing this `(' brace group");
        }
        def group = finish_parent (parent_begin, current_begin);
        Token.RoundGroup (shift_end(loc + e.Location), group, openBrace, null);
      }
    }

    parse_square_group (loc : Location, openBrace : Token.BeginSquare) : Token.SquareGroup
    {
      def parent_begin = parent_stream.Count;
      def current_begin = current_stream.Count;

      def loop () {
        def tok = get_token ();
        match (tok) {
          // finish entire brace group
          | Token.EndSquare as closeBrace =>
            def group = finish_parent (parent_begin, current_begin);
            def groupLoc = loc + tok.Location;
            when (group != null)
              group.Location = groupLoc;
            Token.SquareGroup (groupLoc, group, openBrace, closeBrace);

          // finish current loose group
          | Token.Comma => finish_current (current_begin, tok); loop ()

          | _ => handle_default_token (current_begin, tok, false); loop ()
        }
      }
      try { loop () }
      catch { e is PreParserException =>
        Message.Error (loc, "when parsing this `[' brace group");
        Message.Error (e.Location, e.Message);
        def group = finish_parent (parent_begin, current_begin);
        def groupLoc = loc + e.Location;
        when (group != null)
          group.Location = groupLoc;
        Token.SquareGroup (shift_end(groupLoc), group, openBrace, null);
      }
    }

    parse_quote_group (loc : Location, openBrace : Token.BeginQuote) : Token.QuoteGroup
    {
      def parent_begin = parent_stream.Count;
      def current_begin = current_stream.Count;

      def loop () {
        def tok = get_token ();
        match (tok) {
          // finish entire brace group
          | Token.EndQuote as closeBrace =>
            def group = finish_parent (parent_begin, current_begin);
            Token.QuoteGroup (loc + tok.Location, group, openBrace, closeBrace);

          // finish current loose group
          | Token.Semicolon => finish_current (current_begin, tok); loop ()

          | _ => handle_default_token (current_begin, tok); loop ()
        }
      }
      try { loop () }
      catch { e is PreParserException =>
        Message.Error (loc, "when parsing this `<[' brace group");
        Message.Error (e.Location, e.Message);
        def group = finish_parent (parent_begin, current_begin);
        Token.QuoteGroup (shift_end(loc + e.Location), group, openBrace, null);
      }
    }

  }

}

